[
    {
        "groupName": "实验指导书测试用例",
        "demos": [
            {
                "name": "实验指导书测试用例 test1",
                "irUrl": "demos/textbook/test1.ir",
                "remark": "实验指导书测试用例: test1"
            },
            {
                "name": "实验指导书测试用例 test2",
                "irUrl": "demos/textbook/test2.ir",
                "remark": "实验指导书测试用例: test2"
            },
            {
                "name": "实验指导书测试用例 extra3",
                "irUrl": "demos/textbook/extra3.ir",
                "remark": "实验指导书测试用例: extra3"
            },
            {
                "name": "实验指导书测试用例 extra4",
                "irUrl": "demos/textbook/extra4.ir",
                "remark": "实验指导书测试用例: extra4"
            }
        ]
    },
    {
        "groupName": "普通算法",
        "demos": [
            {
                "name": "二分搜索",
                "irUrl": "demos/ordinary/bsearch.ir",
                "remark": "在1到99中对输入的数进行二分搜索，找到后输出下标，否则输出-1"
            },
            {
                "name": "使用朴素递归方法计算Fib(n)",
                "irUrl": "demos/ordinary/fib0.ir",
                "remark": "O(2^n)，你迫不及待地想试试了吧"
            },
            {
                "name": "使用迭代方法计算Fib(n)",
                "irUrl": "demos/ordinary/fib1.ir",
                "remark": "O(n)，你也觉得这样没有意思吗"
            },
            {
                "name": "使用矩阵乘法计算Fib(n)",
                "irUrl": "demos/ordinary/fib2.ir",
                "remark": "O(logn)，你是否被迷住了呢"
            },
            {
                "name": "使用高级迭代方法计算Fib(n)",
                "irUrl": "demos/ordinary/fib3.ir",
                "remark": "O(logn)，输入n不能超过99"
            },
            {
                "name": "全排列",
                "irUrl": "demos/ordinary/permu.ir",
                "remark": "输入非负整数n，程序会打印{1,...,n}的所有排列，使用11111111分隔"
            }
        ]
    },
    {
        "groupName": "随机数和排序算法",
        "demos": [
            {
                "name": "随机数生成器",
                "irUrl": "demos/rand_sort/rand.ir",
                "remark": "输入正整数n，生成n个32位随机数。本虚拟机对全局变量的支持使得编写随机数生成器成为可能。"
            },
            {
                "name": "快速排序",
                "irUrl": "demos/rand_sort/qsort.ir",
                "remark": "程序生成50个随机数，然后使用快速排序对它们进行升序排序，输出排序后的数组"
            },
            {
                "name": "堆排序",
                "irUrl": "demos/rand_sort/heapsort.ir",
                "remark": "程序生成50个随机数，然后使用堆排序对它们进行升序排序，输出排序后的数组"
            },
            {
                "name": "插入排序",
                "irUrl": "demos/rand_sort/insertsort.ir",
                "remark": "程序生成50个随机数，然后使用插入排序对它们进行升序排序，输出排序后的数组"
            },
            {
                "name": "归并排序",
                "irUrl": "demos/rand_sort/mergesort.ir",
                "remark": "程序生成50个随机数，然后使用归并排序对它们进行升序排序，输出排序后的数组"
            }
        ]
    },
    {
        "groupName": "数学算法",
        "demos": [
            {
                "name": "最大公约数(GCD)",
                "irUrl": "demos/arithmetic/gcd.ir",
                "remark": "输入a和b，使用欧几里得算法计算gcd(a,b)"
            },
            {
                "name": "最小公倍数(LCM)",
                "irUrl": "demos/arithmetic/lcm.ir",
                "remark": "输入a和b，基于欧几里得GCD算法计算lcm(a,b)"
            },
            {
                "name": "扩展欧几里得算法(EGCD)",
                "irUrl": "demos/arithmetic/egcd.ir",
                "remark": "输入a和b(a≥b>0)，输出(d,X,Y)使得d=gcd(a,b)且Xa+Yb=d"
            },
            {
                "name": "32位无符号整数的完整加法",
                "irUrl": "demos/arithmetic/add_uint32.ir",
                "remark": "输入32位有符号整数a和b，以32位无符号整数的形式解释它们并计算a+b，将32位和以有符号数的形式解释，输出和与进位信号"
            },
            {
                "name": "32位无符号整数的完整减法",
                "irUrl": "demos/arithmetic/sub_uint32.ir",
                "remark": "输入32位有符号整数a和b，以32位无符号整数的形式解释它们并计算a-b，将32位差以有符号数的形式解释，输出差与借位信号"
            },
            {
                "name": "32位无符号整数的完整乘法",
                "irUrl": "demos/arithmetic/mul_uint32.ir",
                "remark": "输入32位有符号整数a和b，以32位无符号整数的形式解释它们并计算a*b，将64位乘积的高32位和低32位以有符号数的形式解释并输出"
            },
            {
                "name": "32位无符号整数的除法结果",
                "irUrl": "demos/arithmetic/div_mod_uint32.ir",
                "remark": "输入32位有符号整数a和b，以32位无符号整数的形式解释它们并计算a/b，将商和余数以有符号数的形式解释并输出。使用基于笔算方法的慢除法实现。"
            },
            {
                "name": "32位无符号整数的模乘运算",
                "irUrl": "demos/arithmetic/mul_mod.ir",
                "remark": "输入32位有符号整数a,b和p，以32位无符号整数的形式解释它们并计算(a*b) mod p，将结果以有符号数的形式解释并输出。"
            },
            {
                "name": "32位无符号整数的模指数运算",
                "irUrl": "demos/arithmetic/exp_mod.ir",
                "remark": "输入32位有符号整数a,b和p (b≥0)，以32位无符号整数的形式解释a和p并计算(a^b) mod p，将结果以有符号数的形式解释并输出。使用快速幂算法。"
            },
            {
                "name": "朴素算法素性检验",
                "irUrl": "demos/arithmetic/is_prime_naive.ir",
                "remark": "输入正整数w，使用朴素算法判断w是否是素数。如果w是素数，输出1；如果w是合数，输出0。",
                "vmOptions": {
                    "maxExecutionStepCount": 5000000
                }
            },
            {
                "name": "Miller-Rabin素性检验",
                "irUrl": "demos/arithmetic/miller_rabin.ir",
                "remark": "输入正整数w，使用基于Miller-Rabin素性检验的算法判断w是否*可能*是素数。如果w可能是素数，输出1；如果w是合数，输出0。当w为素数且值达到5亿左右时，此算法对比朴素算法开始显示出执行步数上的优势；当w为合数时，此算法几乎总是非常快。",
                "vmOptions": {
                    "maxExecutionStepCount": 5000000
                }
            },
            {
                "name": "随机素数生成",
                "irUrl": "demos/arithmetic/gen_prime.ir",
                "remark": "输入b和s (2≤b≤31)，随机生成一个b位素数。如果s非零，则生成的是安全素数((p-1)/2同样是素数)。",
                "vmOptions": {
                    "maxExecutionStepCount": 50000000
                }
            }
        ]
    },
    {
        "groupName": "密码学专区❤️",
        "demos": [
            {
                "name": "DH密钥交换：Alice",
                "irUrl": "demos/cryptography/dh_alice.ir",
                "remark": "Alice进行如下步骤：(1)生成并输出DH密钥交换参数(g,p)，其中g为生成元，p=2q+1为24位安全素数；(2)生成私钥x∈Zq，计算并输出公钥h_A=(g^x) mod p；(3)读取Bob的公钥h_B；(4)计算并输出共享密钥k_A=(h_B^x) mod p",
                "vmOptions": {
                    "maxExecutionStepCount": 50000000
                }
            },
            {
                "name": "DH密钥交换：Bob",
                "irUrl": "demos/cryptography/dh_bob.ir",
                "remark": "Bob进行如下步骤：(1)读取Alice生成的DH密钥交换参数(g,p)和公钥h_A；(2)生成私钥y∈Zq，计算并输出公钥h_B=(g^y) mod p；(3)计算并输出共享密钥k_B=(h_A^y) mod p",
                "vmOptions": {
                    "maxExecutionStepCount": 2000000
                }
            }
        ]
    },
    {
        "groupName": "信息安全",
        "demos": [
            {
                "name": "栈溢出攻击",
                "irUrl": "demos/cyber_security/stack_overflow.ir",
                "remark": "在这个虚拟机上也能进行栈溢出攻击吗？"
            }
        ]
    },
    {
        "groupName": "游戏",
        "demos": [
            {
                "name": "猜数游戏",
                "irUrl": "demos/games/guess_game.ir",
                "remark": "程序在[0,32768)内随机生成一个数字，请你来猜！猜小了会输出-1，猜大了会输出1。猜对了会输出什么？"
            }
        ]
    },
    {
        "groupName": "无聊区",
        "demos": [
            {
                "name": "1000个输出",
                "irUrl": "demos/boring/1k_writes.ir",
                "remark": "多乎哉，不多也"
            },
            {
                "name": "Benchmark",
                "irUrl": "demos/boring/benchmark.ir",
                "remark": "性能测试，让虚拟机忙起来！"
            }
        ]
    }
]
